#!/usr/bin/ucode
/*
 * Part of AREDN速 -- Used for creating Amateur Radio Emergency Data Networks
 * Copyright (C) 2025 Tim Wilkinson
 * See Contributors file for additional contributors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation version 3 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Additional Terms:
 *
 * Additional use restrictions exist on the AREDN速 trademark and logo.
 * See AREDNLicense.txt for more info.
 *
 * Attributions to the AREDN速 Project must be retained in the source code.
 * If importing this code into a new or existing project attribution
 * to the AREDN速 project must be added to the source code.
 *
 * You must not misrepresent the origin of the material contained within.
 *
 * Modified versions must be modified to attribute to the original source
 * and be marked in reasonable ways as differentiate it from the original
 * version
 */

let DEBUG = false;

import * as fs from "fs";
import * as socket from "socket";
import * as babel from "mesh.babel";

//
// Supported versions
//

const VERSION_0_0_1 = "0.0.1";
const VERSION_0_0_2 = "0.0.2";
//
// Supported features
//
const FEATURES_CRC          = 0x00000001;
const FEATURES_ALL          = (FEATURES_CRC);
//
// Events
//
const POLLIN                = socket.POLLIN;
const POLLOUT               = socket.POLLOUT;
const POLLRDHUP             = socket.POLLRDHUP;
const POLLTIMER             = 0x10000;
const NOINTERFACE           = 0x20000;
const NEWADDRESS            = 0x40000;
const CLOSECONN             = 0x80000;
//
// Commands
//
const CMD_UPDATE_PUBLISH    = ord("B");
const CMD_UPDATE_SUBSCRIBE  = ord("C");
const CMD_UPDATE_HOSTS      = ord('H');
const CMD_UPDATE_SERVICES   = ord('U');
const CMD_KEEPALIVE         = ord('K');
const CMD_SYNC              = ord('S');
const CMD_VERSION           = ord('V');
//
// Poll timers
//
const NEIGHBORHOOD_POLL     = 60;
const IDLE_POLL             = 60 * 60;
const ROUTE_POLL            = 30;
//
// Connection keepalive
const KEEPALIVE_POLL        = 20;
const KEEPALIVE_LIMIT       = 3;
//
// Gray list timers
//
const GRAY_TIMEOUT          = NEIGHBORHOOD_POLL;
const GRAY_BACKOFF          = 30;
const GRAY_MAX_SCALE        = 15;
//
// TCP configuration
//
const CHANNEL_CONN_TIMEOUT  = 10;
//
// Time to keep data around before deleting it
//
const DELETE_TIMEOUT        = 600;
//
// Communications
//
const MESHLINK_PORT        = 9623;
const MESHLINK_MGR         = "/var/run/meshlink.sock";
const RECV_SIZE            = 32768;
//
// Resources
//
const resources = [
    { name: "hosts",     dir: "/var/run/meshlink/hosts/",      cmd: CMD_UPDATE_HOSTS       },
    { name: "services",  dir: "/var/run/meshlink/services/",   cmd: CMD_UPDATE_SERVICES    },
    { name: "publish",   dir: "/var/run/meshlink/publish/",    cmd: CMD_UPDATE_PUBLISH     },
    { name: "subscribe", dir: "/var/run/meshlink/subscribe/",  cmd: CMD_UPDATE_SUBSCRIBE   }
];
//
// Signals
//
const signals = {
    hosts: null,
    services: null,
    publish: null,
    subscribe: null
};
//
// Default hop count for messages.
//
const HOP_DEFAULT           = 64;
//
// Maximim message size
//
const MAX_MESSAGE_SIZE      = 65535;
//
// Set of all connected channels.
//
const channels = {};
//
// Set of known interfaces
//
let interfaces = {};
//
// Neighborhood monitor
//
let neighborhood = null;
//
// Current babel host routes
//
let hostroutes = {};
//
// Greylist of addresses in timeout
//
const graylist = {};
//
// Set of isolated interfaces
//
const isolated = {};
//
// List of hosts waiting to be removed
//
const pendingremove = {};
//
// Statistics
//
const statistics = {
    count: {
        neighbors: 0,
        routes: 0,
        remove: 0
    },
    incoming: {
        connection: 0,
        sync: 0,
        keepalive: 0,
        version: 0,
        hosts: 0,
        services: 0,
        publish: 0,
        subscribe: 0,
        invalidhop: 0,
        invalidhost: 0,
        badcrc: 0
    },
    outgoing: {
        connection: 0,
        sync: 0,
        keepalive: 0,
        version: 0,
        hosts: 0,
        services: 0,
        publish: 0,
        subscribe: 0
    },
    forward: {
        hosts: 0,
        services: 0,
        publish: 0,
        subscribe: 0
    },
    error: {
        connection: 0,
        version: 0,
        hop: 0,
        command: 0,
        toself: 0,
        keepalive: 0
    }
};
//
// Our IPv4 address, used for all messages we generate
//
const myipv4address = getenv("NODE_IP");
const myipv4iparr = iptoarr(myipv4address);

let channelId = 1;
let exiting = false;
const poller = { fn: null, len: -1 };
const netmodes = {};

//
// Run a signal script (if it exists).
//
function runSignal(name) {
    const script = signals[name];
    if (!script) {
        return null;
    }
    return system(script, 5000) < 0 ? false : true;
}

//
// Compare two addresses and select the best/highest one.
//
function bestAddress(a, b) {
    if (!a) {
        return b;
    }
    if (!b) {
        return a;
    }
    const aa = iptoarr(a);
    const ab = iptoarr(b);
    for (let i = 0; i < 16; i++) {
        if (aa[i] < ab[i]) {
            return b;
        }
        if (aa[i] > ab[i]) {
            return a;
        }
    }
    return a;
}

//
// Is network symmetric? Does everyone have at least one neighbor in common?
//
function isNetworkSymmetric(iface) {
    let mode = netmodes[iface.name];
    if (mode === null) {
        mode = true;
        netmodes[iface.name] = mode;
    }
    return mode;
}

//
// Find channel for the given address.
//
function findChannelByAddress(address) {
    for (let id in channels) {
        if (channels[id].address == address) {
            return channels[id];
        }
    }
    return null;
}

//
// Is a channel connected?
//
function isChannelConnected(channel) {
    return channel.state == "CONNECTED" || channel.state == "CONNECTED_INCOMING";
}

//
// Make events human readable
//
function eventString(polling) {
    if (!polling) {
        return "-";
    }
    let s = "";
    if (polling & POLLIN) {
        s += "|IN";
    }
    if (polling & POLLOUT) {
        s += "|OUT";
    }
    if (polling & POLLRDHUP) {
        s += "|HUP";
    }
    if (polling & POLLTIMER) {
        s += "|TIMER";
    }
    if (polling & NOINTERFACE) {
        s += "|NOIF";
    }
    if (polling & NEWADDRESS) {
        s += "|NEWADDR";
    }
    if (polling & CLOSECONN) {
        s += "|CLOSE";
    }
    return substr(s, 1);
}

//
// Make features human readable.
//
function featureString(features) {
    if (features == 0) {
        return "none";
    }
    let s = "";
    if (features & FEATURES_CRC) {
        s += "|CRC";
    }
    return substr(s, 1);
}

//
// Calculate time for timer
//
function when(timeout) {
    return clock(true)[0] + timeout;
}

//
// Calculate CRC16
//
function crc16(data, start, end) {
    let crc = 0;
    for (let i = start; i < end; i++) {
        let t = (crc >> 8) ^ ord(data, i);
        t = t ^ t >> 4;
        crc = (crc << 8) ^ (t << 12) ^ (t << 5) ^ t;
        crc &= 0xFFFF;
    }
    return crc;
}

//
// Build a message
//
function buildMessage(channel, cmd, ipv4addr, hop, payload) {
    DEBUG && print(`buildMessage: cmd ${chr(cmd)} ip ${ipv4addr} hop ${hop} payload ${payload}\n`);
    payload = payload ?? "";
    const overhead = 8 + (channel.features & FEATURES_CRC ? 2 : 0);
    let len = overhead + length(payload); // Length is the entire message including the length itself.
    if (len > MAX_MESSAGE_SIZE) {
        DEBUG && print(`buildMessage: truncating payload ${ipv4addr}, len = ${len}\n`);
        len = MAX_MESSAGE_SIZE;
        payload = substr(payload, 0, len - overhead);
    }
    const addr = ipv4addr == myipv4address ? myipv4iparr : iptoarr(ipv4addr);
    if (!addr) {
        DEBUG && print(`buildMessage: bad ip address ${ipv4addr}\n`);
        return "";
    }
    let msg = chr(len >> 8, len & 255, cmd, hop , addr[0], addr[1], addr[2], addr[3]) + payload;
    if (channel.features & FEATURES_CRC) {
        const chksum = crc16(msg, 0, length(msg));
        msg += chr(chksum >> 8, chksum & 255);
    }
    return msg;
}

//
// Build a targeted sync message.
//
function buildTargetedSyncMessage(channel) {
    DEBUG && print("buildTargetedSyncMessage:");
    const target = channel.interface;
    let sync = "";
    for (let ip in hostroutes) {
        if (ip !== myipv4address && hostroutes[ip] === target) {
            const addr = iptoarr(ip);
            sync += chr(addr[0], addr[1], addr[2], addr[3]);
            DEBUG && print(` ${ip}`);
        }
    }
    DEBUG && print("\n");
    return length(sync) ? buildMessage(channel, CMD_SYNC, myipv4address, 1, sync) : "";
}

//
// Send message to all (most) of our connected channels.
//
function sendMsgToAll(cmd, ipv4addr, hop, payload, from) {
    const fromifname = from?.interface;
    const highs = {};
    const rest = [];
    for (let id in channels) {
        const channel = channels[id];
        const ifname = channel.interface;
        if (isChannelConnected(channel) && (!from || fromifname === ifname || !isolated[ifname])) {
            if (!channel.rbest || channel.rbest == interfaces[ifname].address) {
                push(rest, channel);
            }
            else if (bestAddress(channel.address, highs[channel.rbest]?.address) == channel.address) {
                highs[channel.rbest] = channel;
            }
        }
    }
    for (let k in highs) {
        push(rest, highs[k]);
    }
    let count = 0;
    for (let i = 0; i < length(rest); i++) {
        const channel = rest[i];
        if (channel != from) {
            channel.outgoing += buildMessage(channel, cmd, ipv4addr, hop, payload);
            channel.polling |= POLLOUT;
            count++;
        }
    }
    return count;
}

//
// Setup our main socket for incoming connections, and the management socket.
//
const main = socket.create(socket.AF_INET6, socket.SOCK_STREAM);
main.setopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);
main.bind({ address: "::", port: MESHLINK_PORT });                             
main.listen();
fs.unlink(MESHLINK_MGR);
const mgr = socket.listen({ path: MESHLINK_MGR }, null, { socktype: socket.SOCK_STREAM });

//
// Process incoming message locally.
//
function processMessage(cmd, hop, srcipv4, payload)
{
    DEBUG && print(`processMessage: cmd ${chr(cmd)} hop ${hop} ip ${srcipv4} payload ${payload}\n`);
    if (srcipv4 === myipv4address) {
        statistics.error.toself++;
        return false;
    }
    switch (cmd) {
        case CMD_VERSION:
            statistics.incoming.version++;
            // v0.0.1: A very simply version sync system - they must match or the connection fails.
            // Downgrade ourselves to v0.0.1 and act appropriately. If we initiated the connection already
            // then the remote side will terminate because we sent it an invalid version number.
            if (payload == VERSION_0_0_1) {
                if (this.state == "CONNECTED_INCOMING") {
                    this.version = VERSION_0_0_1;
                    statistics.outgoing.version++;
                    this.outgoing += buildMessage(this, CMD_VERSION, myipv4address, 1, this.version);
                    statistics.outgoing.sync++;
                    this.outgoing += buildTargettedSyncMessage(this);
                }
            }
            // v0.0.2: The initiator send the version number first together with a feature vector of 16 bits.
            // The target sends back its own version and feature vector. Each end will use only the union of
            // the features. Once each end has received the version information, the sync process can begin.
            else if (substr(payload, 0, 5) == VERSION_0_0_2) {
                this.downgradable = false;
                this.features = ((ord(payload, 5) << 24) + (ord(payload, 6) << 16) + (ord(payload, 7) << 8) + ord(payload, 8)) & FEATURES_ALL;
                if (this.state == "CONNECTED_INCOMING") {
                    statistics.outgoing.version++;
                    this.outgoing += buildMessage(this, CMD_VERSION, myipv4address, 1, this.version);
                }
                statistics.outgoing.sync++;
                this.outgoing += buildTargettedSyncMessage(this);
            }
            // v?.?.?: For unknown versions, v0.0.1 instances just disconnected forcing the other end
            // to recover the connection by downgrading and reconnecting. From v0.0.2 onward the remote
            // end just sends its version information instead, letting the initiator determine how to proceed.
            else {
                this.downgradable = false;
                if (this.state == "CONNECTED_INCOMING") {
                    statistics.outgoing.version++;
                    this.outgoing += buildMessage(this, CMD_VERSION, myipv4address, 1, this.version);
                }
                statistics.error.version++;
            }
            return false;
        case CMD_KEEPALIVE:
            statistics.incoming.keepalive++;
            if (length(payload)) {
                this.rbest = payload;
            }
            return false;
        case CMD_SYNC:
            // A sync request from a neighbor. Payload contains a list of addresses the neighbor is soliciting data for.
            // Return false so the request is not forwarded (it should have a hop of 1);
            statistics.incoming.sync++;
            const len = length(payload);
            for (let i = 0; i <= len - 4; i += 4) {
                const ip = arrtoip([ord(payload, i), ord(payload, i+1), ord(payload, i+2), ord(payload, i+3)]);
                DEBUG && print(`-- syncing ${ip}\n`);
                for (let r = 0; r < length(resources); r++) {
                    const res = resources[r];
                    const data = fs.readfile(`${res.dir}${ip}`);
                    if (data !== null) {
                        DEBUG && print(`-- sending ${res.dir}${ip}\n`);
                        statistics.outgoing[res.name]++;
                        this.outgoing += buildMessage(this, res.cmd, ip, HOP_DEFAULT, data);
                    }
                }
            }
            return false;
        default:
            const validif = hostroutes[srcipv4] === this.interface ? true : false;
            const validhost = !!hostroutes[srcipv4];
            // Under some circumstances (see below) we might accept a resource from an invalid interface,
            // it must still be from a valid host.
            if (!validhost) {
                statistics.incoming.invalidhost++;
                return false;
            }
            for (let r = 0; r < length(resources); r++) {
                const res = resources[r];
                if (cmd === res.cmd) {
                    const path = `${res.dir}${srcipv4}`;
                    const old = fs.readfile(path);
                    // If the message is from an invalid host interface then we ignore it unless
                    // we don't have any current resource, in which case we'll take it anyway.
                    if (!validif && old !== null) {
                        statistics.incoming.invalidhop++;
                        return false;
                    }
                    statistics.incoming[res.name]++;
                    if (old == payload) {
                        return false;
                    }
                    fs.writefile(path, payload);
                    runSignal(res.name);
                    return true;
                }
            }
            statistics.error.command++;
            return false;
    }
}

//
// Process incoming data from another node.
//
function processRequest() {
    DEBUG && print(`processRequest channel ${this}\n`);
    const data = this.connection.recv(RECV_SIZE);
    DEBUG && print(`--- data length ${length(data)}\n`);
    if (!data || !length(data)) {
        return false;
    }
    this.incoming += data;
    const ilen = length(this.incoming);
    DEBUG && print(`--- incoming length ${ilen}\n`);
    // Process the incoming data
    let i = 0;
    while (i < ilen) {
        // Make sure we have enough to read the length
        if (i + 2 > ilen) {
            break;
        }
        DEBUG && print(`--- header [ ${ord(this.incoming, i+0)}, ${ord(this.incoming, i+1)}, ${ord(this.incoming, i+2)}, ${ord(this.incoming, i+3)}, ${ord(this.incoming, i+4)}, ${ord(this.incoming, i+5)}, ${ord(this.incoming, i+6)}, ${ord(this.incoming, i+7)} ]\n`);
        const len = 256 * ord(this.incoming, i) + ord(this.incoming, i + 1);
        DEBUG && print(`--- msg length ${len}\n`);
        // Then make sure we have enough to read the packet.
        if (i + len > ilen) {
            break;
        }
        const cmd = ord(this.incoming, i + 2);
        const hop = ord(this.incoming, i + 3);
        const srcipv4 = [ ord(this.incoming, i + 4), ord(this.incoming, i + 5), ord(this.incoming, i + 6), ord(this.incoming, i + 7) ];
        const srcipv4str = arrtoip(srcipv4);
        DEBUG && print(`--- msg ${chr(cmd)} hop ${hop} ${srcipv4src}\n`);
        let overhead = 8;
        if (this.features & FEATURES_CRC) {
            overhead += 2;
            const chksum = crc16(this.incoming, i, i + len - 2);
            const rchksum = 256 * ord(this.incoming, i + len - 2) + ord(this.incoming, i + len - 1);
            if (chksum !== rchksum) {
                DEBUG && print(`--- bad crc ${chksum} recv ${rchksum}\n`);
                statistics.incoming.badcrc++;
                // Bad CRCs are fatal as it suggests the stream is corrupted. Terminate it and let it restart.
                this.process(CLOSECONN);
                i = ilen;
                break;
            }
        }
        const payload = substr(this.incoming, i + 8, len - overhead);
        const forward = call(processMessage, this, null, cmd, hop, srcipv4str, payload);
        if (forward) {
            if (hop > 1) {
                // Build and forward message
                const count = sendMsgToAll(cmd, srcipv4str, hop - 1, payload, this);
                for (let r = 0; r < length(resources); r++) {
                    const res = resources[r];
                    if (cmd === res.cmd) {
                        statistics.forward[res.name] += count;
                        break;
                    }
                }
            }
            else {
                statistics.error.hop++;
            }
        }
        i += len;
    }
    if (i >= ilen) {
        this.incoming = "";
    }
    else {
        this.incoming = substr(this.incoming, i);
    }
    return true;
}

//
// Process the current channel, potentially consuming or sending traffic on the socket
// if the event says we can.
// this: channel
//
function channelProcess(event) {
    DEBUG && print(`channelProcess: id ${this.id} event ${eventString(event)} state ${this.state} address ${this.address ?? '<none>'}\n`);
    switch (this.state) {
        case "IDLE":
        {
            switch (event) {
                case NEWADDRESS:
                    this.state = "NEW";
                    this.timer = 0;
                    break;
                case NOINTERFACE:
                case CLOSECONN:
                    this.state = "EXIT";
                    this.timer = 0;
                    break;
                case POLLTIMER:
                default:
                    this.timer = when(IDLE_POLL);
                    break;
            }
            break;
        }
        case "NEW":
        {
            switch (event) {
                case POLLTIMER:
                    statistics.outgoing.connection++;
                    DEBUG && print(`Connecting to ${this.address} on ${this.interface}\n`);
                    this.connection = socket.connect({ interface: this.interface, address: this.address, port: MESHLINK_PORT }, null, null, CHANNEL_CONN_TIMEOUT * 1000);
                    DEBUG && print(`Connection: ${this.connection}\n`);
                    if (!this.connection) {
                        // Failed to connect
                        // Timeout address to graylist
                        statistics.error.connection++;
                        const key = `${this.interface}/${this.address}`;
                        const g = graylist[key];
                        if (g) {
                            g.scale = min(g.scale * 1.5, GRAY_MAX_SCALE);
                            g.timer = when(GRAY_TIMEOUT + GRAY_BACKOFF * g.scale);
                        }
                        else {
                            graylist[key] = { timer: when(GRAY_TIMEOUT), scale: 1 };
                        }
                        this.state = "EXIT";
                        this.timer = 0;
                    }
                    else {
                        // No longer gray (in case were were)
                        delete graylist[`${this.interface}/${this.address}`];
                        this.state = "CONNECTED";
                        this.polling = POLLIN|POLLOUT|POLLRDHUP;
                        this.keepalive = 0;
                        this.keepalivetime = when(KEEPALIVE_POLL);
                        this.timer = this.keepalivetime;
                        this.incoming = "";
                        this.downgradable = this.version == VERSION_0_0_1 ? false : true;
                        statistics.outgoing.version++;
                        this.outgoing = buildMessage(this, CMD_VERSION, myipv4address, 1, this.version);
                    }
                    break;
                case NEWADDRESS:
                case NOINTERFACE:
                case CLOSECONN:
                default:
                    this.state = "EXIT";
                    this.timer = 0;
                    break;
            }
            break;
        }
        case "CONNECTED":
        {
            switch (event) {
                case POLLIN:
                case POLLRDHUP|POLLIN:
                    if (!call(processRequest, this) && (event & POLLRDHUP)) {
                        this.polling &= ~POLLIN;
                    }
                    this.keepalive = 0;
                    this.timer = this.keepalivetime;
                    break;
                case POLLOUT:
                case POLLIN|POLLOUT:
                    const sent = this.connection.send(this.outgoing);
                    if (sent == length(this.outgoing)) {
                        this.outgoing = "";
                        this.polling &= ~POLLOUT;
                    }
                    else if (sent !== null) {
                        this.outgoing = substr(this.outgoing, sent);
                    }
                    else {
                        // Error - close because we dont know the state anymore
                        this.state = "EXIT";
                        this.polling = 0;
                        this.timer = 0;
                        break;
                    }
                    this.keepalivetime = when(KEEPALIVE_POLL);
                    this.timer = this.keepalivetime;
                    break;
                case POLLRDHUP:
                case POLLRDHUP|POLLOUT:
                case POLLRDHUP|POLLIN|POLLOUT:
                    if (this.connection) {
                        this.connection.close();
                        this.connection = null;
                    }
                    this.polling = 0;
                    this.incoming = "";
                    this.outgoing = "";
                    if (this.downgradable) {
                        // Downgrade the version and try the connection again.
                        this.downgradable = false;
                        this.version = VERSION_0_0_1;
                        this.state = "NEW";
                    }
                    else {
                        this.state = "EXIT";
                    }
                    // Force neighbor update
                    neighborhood.timer = 0;
                    this.timer = 0;
                    break;
                case POLLTIMER:
                    this.keepalive++;
                    if (this.keepalive < KEEPALIVE_LIMIT) {
                        statistics.outgoing.keepalive++;
                        this.outgoing += buildMessage(this, CMD_KEEPALIVE, myipv4address, 1, interfaces[this.interface]?.best);
                        this.keepalivetime = when(KEEPALIVE_POLL);
                        this.timer = this.keepalivetime;
                        break;
                    }
                    statistics.error.keepalive++;
                    // Fall through
                case NEWADDRESS:
                case NOINTERFACE:
                case CLOSECONN:
                default:
                    this.polling = 0;
                    this.state = "EXIT";
                    this.timer = 0;
                    break;
            }
            break;
        }
        case "INCOMING":
        {
            statistics.incoming.connection++;
            this.incoming = "";
            this.outgoing = "";
            this.state = "CONNECTED_INCOMING";
            this.keepalive = 0;
            this.keepalivetime = when(KEEPALIVE_POLL);
            this.polling = POLLIN|POLLOUT|POLLRDHUP;
            // No longer grey
            delete graylist[`${this.interface}/${this.address}`];
            // Fall through
        }
        case "CONNECTED_INCOMING":
        {
            switch (event) {
                case POLLIN:
                case POLLRDHUP|POLLIN:
                    if (!call(processRequest, this) && (event & POLLRDHUP)) {
                        this.polling &= ~POLLIN;
                    }
                    this.keepalive = 0;
                    this.timer = this.keepalivetime;
                    break;
                case POLLOUT:
                case POLLIN|POLLOUT:
                    const sent = this.connection.send(this.outgoing);
                    if (sent == length(this.outgoing)) {
                        this.outgoing = "";
                        this.polling &= ~POLLOUT;
                    }
                    else if (sent !== null) {
                        this.outgoing = substr(this.outgoing, sent);
                    }
                    else {
                        // Error - close because we dont know the state anymore
                        this.state = "EXIT";
                        this.polling = 0;
                        this.timer = 0;
                        break;
                    }
                    this.keepalivetime = when(KEEPALIVE_POLL);
                    this.timer = this.keepalivetime;
                    break;
                case POLLTIMER:
                    this.keepalive++;
                    if (this.keepalive < KEEPALIVE_LIMIT) {
                        statistics.outgoing.keepalive++;
                        this.outgoing += buildMessage(this, CMD_KEEPALIVE, myipv4address, 1, interfaces[this.interface]?.best);
                        this.keepalivetime = when(KEEPALIVE_POLL);
                        this.timer = this.keepalivetime;
                        break;
                    }
                    statistics.error.keepalive++;
                    // Fall through
                case POLLRDHUP:
                case POLLRDHUP|POLLOUT:
                case POLLRDHUP|POLLIN|POLLOUT:
                    // Force neighbor update
                    neighborhood.timer = 0;
                    // Fall through
                case NEWADDRESS:
                case CLOSECONN:
                case NOINTERFACE:
                default:
                    this.state = "EXIT";
                    this.polling = 0;
                    this.timer = 0;
                    break;
            }
            break;
        }
        case "EXIT":
        default:
        {
            this.state = "CLOSED";
            if (this.connection) {
                this.connection.close();
                this.connection = null;
            }
            delete channels[this.id];
            break;
        }
    }
    if (length(this.outgoing)) {
        this.polling |= POLLOUT;
    }
}

//
// Create a new channel to manage the socket. The channel may be for an incoming
// comnnection, or for one we're initiating.
//
function createChannel(initialstate, connection, polling, timer, process) {
    DEBUG && print(`createChannel: state ${initialstate} connection ${connection} polling ${eventString(polling)} timer ${timer}\n`);
    const channel = {
        id: channelId++,
        state: initialstate,
        connection: connection,
        polling: polling,
        timer: timer,
        version: VERSION_0_0_2 + chr(FEATURES_ALL >> 24, (FEATURES_ALL >> 16) & 255, (FEATURES_ALL >> 8) & 255, FEATURES_ALL & 255),
        features: 0,
        incoming: "",
        outgoing: ""
    };
    if (!process) {
        process = channelProcess;
    }
    channel.process = (event) => call(process, channel, null, event),
    channels[channel.id] = channel;
    return channel;
}

//
// Commands
//
function commandProcess(cmd) {
    const cv = split(trim(cmd), " ", 2);
    cv[1] = trim(cv[1]);
    switch (cv[0]) {
        case "upload":
        {
            const tf = split(cv[1], " ", 2);
            const type = tf[0];
            const data = fs.readfile(trim(tf[1]));
            if (data === null) {
                return "bad file";
            }
            for (let r = 0; r < length(resources); r++) {
                const res = resources[r];
                if (res.name === type) {
                    const path = `${res.dir}${myipv4address}`;
                    const old = fs.readfile(path);
                    if (old == data) {
                        return "ok nochange";
                    }
                    fs.writefile(path, data);
                    const count = sendMsgToAll(res.cmd, myipv4address, HOP_DEFAULT, data, null);
                    statistics.outgoing[res.name] += count;
                    runSignal(res.name);
                    return old ? "ok updated" : "ok new";
                }
            }
            return "bad name";
        }
        case "signal":
        {
            const tf = split(cv[1], " ", 2);
            const type = tf[0];
            const script = trim(tf[1]);
            if (type in signals) {
                signals[type] = null;
                if (length(script)) {
                    signals[type] = script;
                }
                return "ok";
            }
            return "bad signal";
        }
        case "dump":
        {
            const now = when(0);
            let r = "";
            for (let i in interfaces) {
                r += `interface ${i} address ${interfaces[i].address} chanout ${length(filter(values(channels), c => c.state == "CONNECTED" && c.interface == i))} chanin ${length(filter(values(channels), c => c.state == "CONNECTED_INCOMING" && c.interface == i))}${isNetworkSymmetric(interfaces[i]) ? " symmetric" : ""}${interfaces[i].address == interfaces[i].best ? " best" : ""}\n`;
            }
            for (let i in isolated) {
                r += `isolated ${i}\n`;
            }
            for (let id in channels) {
                const c = channels[id];
                r += `channel ${id} state ${c.state} v${c.version == VERSION_0_0_1 ? VERSION_0_0_1 : VERSION_0_0_2} interface ${c.interface ?? "-"} address ${c.address ?? "-"} rbest ${c.rbest ?? "-"} features ${featureString(c.features)} polling ${eventString(c.polling)} timer ${c.timer === null ? "-" : c.timer == 0 ? "0" : c.timer - now} keepalive ${c.keepalive ?? "-"} in-len ${length(c.incoming) ?? "-"} out-len ${length(c.outgoing) ?? "-"}\n`;
            }
            for (let k in statistics) {
                r += `statistics ${k}`;
                const stat = statistics[k];
                for (let j in stat) {
                    r += ` ${j} ${stat[j]}`;
                }
                r += "\n";
            }
            return r + "ok";
        }
        case "isolate":
            if (length(cv[1])) {
                isolated[cv[1]] = true;
                return "ok";
            }
            else {
                return "bad";
            }
        case "quit":
            return "ok quitting";
        case "debug":
            DEBUG = cv[1] === "on" ? true : false;
            return "ok";
        case "":
            return null;
        default:
            return "bad command";
    }
}

//
// Process manager commands.
// this: channel
//
function managerProcess(event) {
    switch (this.state) {
        case "INCOMING":
            this.connection.send(`MeshLink ${VERSION_0_0_2}\n`);
            this.state = "READING";
            this.polling &= ~POLLOUT;
            // Fall through
        case "READING":
        default:
        {
            let close = false;
            if (event & POLLIN) {
                const d = this.connection.recv();
                if (d === "" && (event & POLLRDHUP)) {
                    close = true;
                }
                const cmds = split(d, "\n");
                for (let i = 0; i < length(cmds) && this.state != "CLOSED"; i++) {
                    const r = commandProcess(cmds[i]);
                    if (r) {
                        this.connection.send(`${r}\n`);
                        if (r === "ok quitting") {
                            close = true;
                        }
                    }
                }
            }
            else if (event & POLLRDHUP) {
                close = true;
            }
            if (close) {
                this.state = "CLOSED";
                this.polling = 0;
                this.connection.close();
                delete channels[this.id];
            }
            break;
        }
    }
}

//
// Monitor the neighborhood
//
function neighborhoodProcess(event) {
    DEBUG && print("neighborhoodProcess\n");
    const ifaces = babel.getInterfaces();
    if (length(ifaces)) {
        const oldinterfaces = interfaces;
        interfaces = {};
        for (let i = 0; i < length(ifaces); i++) {
            const iface = ifaces[i];
            const name = iface.interface;
            if (name === "br-nomesh") {
                // Ignore interfaces which cannot have neighbors
            }
            else if (oldinterfaces[name]) {
                interfaces[name] = oldinterfaces[name];
                oldinterfaces[name] = null;
            }
            else {
                // Found new interface
                interfaces[name] = { name: name, address: iface.ipv6address, best: iface.ipv6address };
            }
        }
        for (let name in oldinterfaces) {
            // Close any open channels on this interface
            if (oldinterfaces[name]) {
                for (let id in channels) {
                    const channel = channels[id];
                    if (channel.interface == name) {
                        channel.timer = null;
                        channel.process(NOINTERFACE);
                    }
                }
                // Remove any graylist entries when the interface disappears
                for (let key in graylist) {
                    if (index(key, name) === 0) {
                        delete graylist[key];
                    }
                }
            }
        }
    }

    // Get list of neighbors we might connect to.
    const neighbors = babel.getNeighbors();
    if (length(neighbors)) { 
        const nlength = length(neighbors);
        statistics.count.neighbors = nlength;
        const now = when(0);
        const ifgroups = {};
        // Sort the neighbors into groups based on their interfaces, and track which is the best one for each.
        for (let i = 0; i < nlength; i++) {
            const n = neighbors[i];
            const gray = graylist[`${n.interface}/${n.ipv6address}`];
            if (!gray || gray.timer < now) {
                const iface = interfaces[n.interface];
                if (iface) {
                    if (!ifgroups[n.interface]) {
                        ifgroups[n.interface] = { b: iface.address, n: [] };
                    }
                    ifgroups[n.interface].b = bestAddress(ifgroups[n.interface].b, n.ipv6address);
                    push(ifgroups[n.interface].n, n.ipv6address);
                }
            }
        }
        // For each interface we work out who we need to be connected to.
        for (let ifname in ifgroups) {
            const iface = interfaces[ifname];
            const myaddress = iface.address;
            const bestaddress = ifgroups[ifname].b;
            const neighaddresses = ifgroups[ifname].n;

            // Always have a connection to the best address (unless that's me)
            iface.best = bestaddress;
            if (bestaddress != myaddress && !findChannelByAddress(bestaddress)) {
                const channel = createChannel("IDLE", null, 0, 0, null);
                channel.interface = ifname;
                channel.myaddress = myaddress;
                channel.address = bestaddress;
                channel.process(NEWADDRESS);
            }

            if (isNetworkSymmetric(iface)) {
                // If network is symmetric, close every other channel I created on this interface except the best one.
                for (let id in channels) {
                    const channel = channels[id];
                    if (channel.interface == ifname && bestaddress != channel.address && channel.state === "CONNECTED") {
                        channel.process(CLOSECONN);
                    }
                }
            }
            else {
                // If network is asymmetric, open a channel to every neighbor better than me and close any which are worse.
                // This creates far too much network traffic, but because we can have hidden nodes, there's no good other options.
                for (let i = 0; i < length(neighaddresses); i++) {
                    const nipv6addr = neighaddresses[i];
                    let channel = findChannelByAddress(nipv6addr);
                    if (bestAddress(myaddress, nipv6addr) == nipv6addr) {
                        if (!channel) {
                            channel = createChannel("IDLE", null, 0, 0, null);
                            channel.interface = ifname;
                            channel.myaddress = myaddress;
                            channel.address = nipv6addr;
                            channel.process(NEWADDRESS);
                        }
                    }
                    else {
                        if (channel && channel.state === "CONNECTED") {
                            channel.process(CLOSECONN);
                        }
                    }
                }
            }
        }
    }

    // Run GC now as this has all been very memory expensive
    gc("collect");

    this.timer = when(NEIGHBORHOOD_POLL);
}

//
// Monitor Babel route changes.
//
function routeProcess(event) {
    DEBUG && print("routeProcess\n");
    const broutes = babel.getHostRoutes();

    statistics.count.routes = length(broutes);

    const oldr = hostroutes;
    const newr = {};
    hostroutes = {};
    for (let i = length(broutes) - 1; i >= 0; i--) {
        const route = broutes[i];
        const dst = route.dst;
        const iface = route.oif;
        hostroutes[dst] = iface;
        if (oldr[dst] !== iface) {
            // New route or an old route on an new interface
            // Build the sync message payloads as we go
            const addr = iptoarr(dst);
            if (!newr[iface]) {
                newr[iface] = "";
            }
            newr[iface] += chr(addr[0], addr[1], addr[2], addr[3]);
        }
        oldr[dst] = null;
        delete pendingremove[dst];
    }

    // Any data no longer need it marked for later deletion
    const sigs = {};
    for (let ip in oldr) {
        if (oldr[ip]) {
            pendingremove[ip] = when(DELETE_TIMEOUT);
        }
    }

    // Remove any data which is too old
    const now = when(0);
    statistics.count.remove = 0;
    for (let ip in pendingremove) {
        if (pendingremove[ip] < now) {
            for (let r = 0; r < length(resources); r++) {
                if (fs.unlink(`${resources[r].dir}${ip}`)) {
                    sigs[resources[r].name] = true;
                }
            }
            delete pendingremove[ip];
        } else {
            statistics.count.remove++;
        }
    }

    // Call any signals we need toAdd commentMore actions
    for (let name in sigs) {
        runSignal(name);
    }

    // Sync our neighbors for information about the new routes
    for (let id in channels) {
        const channel = channels[id];
        const sync = newr[channel.interface];
        if (sync && isChannelConnected(channel)) {
            channel.outgoing += buildMessage(channel, CMD_SYNC, myipv4address, 1, sync);
            channel.polling |= POLLOUT;
        }
    }

    // Run GC now as this has all been very memory expensive
    gc("collect");

    this.timer = when(ROUTE_POLL);
}

//
// Our main socket process handles incoming requests, accepts them
// then creates a channel to manage them.
//
function mainProcess(event) {
    if (event & POLLIN) {
        const address = {};
        const channel = createChannel("INCOMING", main.accept(address, socket.SOCK_NONBLOCK), POLLIN|POLLRDHUP, null, null);
        channel.interface = address.interface;
        channel.address = address.address;
    }
}

//
// Our mgr socket profcess handles incoming manage requests, accepts them
// then creates a channel to handle the incoming manager calls.
//
function mgrProcess(event) {
    if (event & POLLIN) {
        createChannel("INCOMING", mgr.accept(), POLLIN|POLLOUT|POLLRDHUP, null, managerProcess);
    }
}

//
// Work out what to poll and poll it.
// NOTE: Because socket.poll takes a list of arguments and not an array, and because there
// is no fn.apply(...) method, we use 'loadstring' to build our own. We keep it around and
// only rebuild it when the argument count changes. Maybe I'm missing an easier way to do this?
//
function pollWorkers() {
    const workers = [];
    let timeout = 24 * 60 * 60; // 1 day
    const now = when(0);
    for (let id in channels) {
        const channel = channels[id];
        if (channel.timer !== null) {
            timeout = min(timeout, channel.timer - now);
        }
        if (channel.connection && channel.polling) {
            push(workers, [ channel.connection, channel.polling, channel ]);
        }
        else if (channel.timer === null) {
            print(`ERROR: Worker blocked without timer or active socket: ${channel}\n`);
        }
    }
    if (length(workers) !== poller.len) {
        poller.len = length(workers);
        let p = "import * as socket from 'socket';return function(t,w){ return socket.poll(t";
        for (let count = 0; count < poller.len; count++) {
            p += `,w[${count}]`;
        }
        p += ");}";
        poller.fn = loadstring(p, { raw_mode: true })();
    }
    timeout = max(0, timeout);
    DEBUG && printf(`POLL timeout ${timeout} workers ${workers}\n`);
    return poller.fn(1000 * timeout, workers) || [];
}

//
// Signals
//
signal("SIGINT", _ => exiting = true);
signal("SIGTERM", _ => exiting = true);

//
// Create resource directories and empty them.
//
for (let r = 0; r < length(resources); r++) {
    system(`/bin/mkdir -p ${resources[r].dir}`);
    system(`/bin/rm -f ${resources[r].dir}*`);
}

//
// Start connecting
//
createChannel("MAIN", main, POLLIN, null, mainProcess);
createChannel("MGR", mgr, POLLIN, null, mgrProcess);
createChannel("ROUTES", null, 0, 0, routeProcess);
neighborhood = createChannel("NEIGHBORHOOD", null, 0, when(5), neighborhoodProcess);

//
// Command line
//
for (let i = 0; i < length(ARGV); i++) {
    if (ARGV[i] === "-C") {
        commandProcess(ARGV[i + 1]);
        i++;
    }
    else {
        print("Bad command line argument: " + ARGV[i]);
    }
}

//
// Run until exit
//
while (!exiting) {
    // Poll for any sockets which we can dispatch
    const events = pollWorkers();
    DEBUG && printf("Dispatching %s\n", events);
    for (let i = 0; i < length(events); i++) {
        const event = events[i];
        if (event[1]) {
            event[2].timer = null;
            event[2].process(event[1] & (POLLIN|POLLOUT|POLLRDHUP));
        }
    }
    // Check for expired timers
    const now = when(0);
    for (let id in channels) {
        const channel = channels[id];
        if (channel.timer !== null && channel.timer <= now) {
            channel.timer = null;
            channel.process(POLLTIMER);
        }
    }
    DEBUG && printf("GC count %d\n", gc("count"));
}

DEBUG && print("Exiting\n");
//
// Tidy up connections on the way out
//
main.close();
for (let id in channels) {
    if (channels[id].connection) {
        channels[id].connection.close();
    }
}
mgr.close();
